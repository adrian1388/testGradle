package com.test.apolloAndroid;

import java.net.InetAddress;
import java.net.UnknownHostException;
import java.time.LocalDateTime;
import java.util.UUID;

import javax.annotation.PostConstruct;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.apollographql.apollo.ApolloCall;
import com.apollographql.apollo.ApolloClient;
import com.apollographql.apollo.ApolloSubscriptionCall;
import com.apollographql.apollo.api.Response;
import com.apollographql.apollo.exception.ApolloException;
import com.apollographql.apollo.internal.subscription.ApolloSubscriptionTerminatedException;
import com.apollographql.apollo.rx2.Rx2Apollo;
import com.test.client.Connection;
import com.test.data.model.Setting;
import com.test.data.repository.SettingRepository;
import com.test.FindOfficeByIdQuery;
import com.test.FindSensorByIdQuery;
import com.test.FindSnapshotChanges2Subscription;
import com.test.RegisterMutation;

import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.DisposableSubscriber;

/**
 * This Java source file was generated by the Gradle 'init' task.
 * 
 * Rest Endpoints
 */
@RestController
public class GraphQLClientLibrary {

    protected final Log logger = LogFactory.getLog(getClass());
    private final CompositeDisposable disposables = new CompositeDisposable();
    private final String coordinatorSettingName = "CoordinatorId";

    String responseString = "";
    Boolean subscriptionConnected = false;
    Boolean internetBoolean = true;

    @Value("${coordinatorId:null}")
    private String coordinatorIdFromAppProp;

    ApolloSubscriptionCall<FindSnapshotChanges2Subscription.Data> subscriptionCall;
    ApolloCall<RegisterMutation.Data> registerCall;

    @Autowired
    private ApolloClient apolloClient;

    @Autowired
    private Connection connection;

    @Autowired
    private SettingRepository settingRepository;

    /**
     * Subscribes to Central Server to receive and update Key and Token for this Coordinator.
     */
    @PostConstruct
    public void init() {

        String coordinatorId = getCoordinatorId();
        // Subscription to receive login params
        FindSnapshotChanges2Subscription subscription = FindSnapshotChanges2Subscription.builder()
            .id(UUID.fromString(coordinatorId))
            .build();
        subscriptionCall = apolloClient
            .subscribe(subscription);

//        try {
//			Thread.sleep(1000);
//		} catch (InterruptedException e) {
//			logger.error(e.getCause());
//		}
//        
//        testRegister(coordinatorId);
        // login params
        String key = settingRepository.findByName("key").orElse(new Setting()).getValue();
        String token = settingRepository.findByName("token").orElse(new Setting()).getValue();
        
        // Logging in
//        if (key != null && token != null && !key.isEmpty() && !token.isEmpty()) {
//            login(key,token);
//        }
    }

    /**
     * Subscription tester method
     * 
     * @return Boolean
     */
    @GetMapping(value = "testSubscription")
    public String testSubscription() {

        String coordinatorId = getCoordinatorId();
        FindSnapshotChanges2Subscription subscription = FindSnapshotChanges2Subscription.builder()
            .id(UUID.fromString(coordinatorId)) //coordinator id (subject id)
            .build();
        subscriptionCall = apolloClient
            .subscribe(subscription);

        disposablesAdd(subscriptionCall);

        return responseString;
    }
    
    public void disposablesAdd(ApolloSubscriptionCall<FindSnapshotChanges2Subscription.Data> subscriptionCall) {

        subscriptionConnected = true;

        logger.info("Disposables size BEFORE add: " + disposables.size());
        disposables.add(Rx2Apollo.from(subscriptionCall)
            .subscribeOn(Schedulers.io())
            .subscribeWith(
                new DisposableSubscriber<Response<FindSnapshotChanges2Subscription.Data>>() {
                    @Override
                    public void onNext(Response<FindSnapshotChanges2Subscription.Data> response) {
                        String key = response.data().findSnapshotChanges2().key();
                        String token = response.data().findSnapshotChanges2().token();
                        
                        logger.info("Subscription response KEY: " + key);
                        logger.info("Subscription response TOKEN: " + token);
                        
                        // Key
                        Setting keySetting = settingRepository.findByName("key").orElseGet(() -> {
                            Setting s = new Setting();
                            s.setName("key");
                            return s;
                        });
                        keySetting.setValue(key);
                        keySetting.setUpdatdOn(LocalDateTime.now());
                        settingRepository.save(keySetting);

                        // Token
                        Setting tokenSetting = settingRepository.findByName("token").orElseGet(() -> {
                            Setting s = new Setting();
                            s.setName("token");
                            return s;
                        });
                        tokenSetting.setValue(token);
                        tokenSetting.setUpdatdOn(LocalDateTime.now());
                        settingRepository.save(tokenSetting);

                        // if loggedIn, logout() and login(..,..) again
                        if (connection.loggedIn()) {
                            logout();

                            try {
                    			Thread.sleep(1000);
                    		} catch (InterruptedException e) {
                    			logger.error(e.getCause());
                    		}
                            
                            login(key, token);
                        } else {
                            logger.info("Logging in now.");
                            login(key, token);
                        }
                    }

                    @Override
                    public void onError(Throwable e) {
	                    logger.error("Subscription failure: " + e);
	                    if (e instanceof ApolloSubscriptionTerminatedException) {
	                        logger.debug("**** Unsubsribing... ApolloSubscriptionTerminatedException");
	                    }
	                    cancelSubscription();
                    }

                    @Override
                    public void onComplete() {
                        logger.debug("Subscription exhausted");
                    }
                }
            )
        );
        logger.info("Disposables size AFTER add: " + disposables.size());
    }

//    @Scheduled(fixedDelay = 1000 * 15)
    public void scanSubscription() {

        try {
            if (!internetBoolean && !"127.0.0.1".equals(InetAddress.getLocalHost().getHostAddress().toString())) {
                subscriptionConnected = false;
            }
            internetBoolean = !"127.0.0.1".equals(InetAddress.getLocalHost().getHostAddress().toString());
            logger.info("Internet? " + internetBoolean + " ---> " + InetAddress.getLocalHost().getHostAddress());
            if (subscriptionCall != null && logger.isDebugEnabled()) {
            	logger.info("Subscription canceled? " + subscriptionCall.isCanceled());
            }
        } catch (UnknownHostException e1) {
        	logger.error(e1.getMessage());
        }
        logger.info("SUBSCRIPTION CALL2: " + subscriptionCall);
        if (!subscriptionConnected && subscriptionCall != null) {
            logger.info("**** initConnection: NOT Connected. cloning & subscribing!!");
            cancelSubscription();
            subscriptionCall = subscriptionCall.clone();
            disposablesAdd(subscriptionCall);
        }
    }

    private void cancelSubscription() {
        logger.info("**** canceling Subscription");
        subscriptionConnected = false;
        subscriptionCall.cancel();
        disposables.clear();
    }

    /**
     * Mutation tester method
     * 
     * @return Boolean
     */
    @GetMapping(value = "testRegister")
    public Boolean testRegister(
    	@RequestParam("id")
    	String id
    ) {

        System.out.println(" REG ini: " + id);
        RegisterMutation mutation = RegisterMutation.builder()
        	.id(UUID.fromString(id))
            .build();
        registerCall = apolloClient
            .mutate(mutation);
        
        registerCall.enqueue(new ApolloCall.Callback<RegisterMutation.Data>() {
            @Override
            public void onResponse(
                Response<RegisterMutation.Data> response
            ) {
                System.out.println(" REG RESPONSE: " + response.data());
            }

            @Override
            public void onFailure(
                ApolloException e
            ) {
                System.out.println(" REG ERROR: " + e);
            }

        });

        return true;
    }

    /**
     * login
     * 
     * @return Boolean
     */
    @GetMapping(value = "login")
    public Boolean login(@RequestParam String username, @RequestParam String password) {

        connection.login(username, password);

        if (connection.getCookies() != null && connection.getToken() != null) {
            logger.info(" ****** LOGGEDIN ****** ");
            return true;
        } else {
            logger.error(" ****** Error Logging in ****** ");
            return false;
        }
    }

    /**
     * Calls Connection.logout()
     * 
     * @return True when successfully logout
     */
    @GetMapping(value = "logout")
    public Boolean logout() {
        connection.logout();
        return true;
    }

    // Saving Coordinator Id to or getting from Setting
    private String getCoordinatorId() {
        Setting coordinatorIdSetting = settingRepository.findByName(coordinatorSettingName).orElseGet(() -> {
            Setting s = new Setting();
            s.setName(coordinatorSettingName);
            return s;
        });

        if (coordinatorIdSetting.getValue() == null && coordinatorIdFromAppProp != null) {
            logger.info("Coordinator Id found on application.properties file: " + coordinatorIdFromAppProp);
            
            coordinatorIdSetting.setValue(coordinatorIdFromAppProp);
        } else if (coordinatorIdFromAppProp == null) {
            String temp = UUID.randomUUID().toString();
            logger.info("Random Coordinator Id generated: " + temp);
            
            coordinatorIdSetting.setValue(temp);
        }

        coordinatorIdSetting.setUpdatdOn(LocalDateTime.now());
        coordinatorIdSetting = settingRepository.save(coordinatorIdSetting);

        return coordinatorIdSetting.getValue();
    }
}
